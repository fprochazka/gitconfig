#!/usr/bin/env bash

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/lib/common.sh"

#
# Usage
#

usage() {
    cat <<EOF
Usage: git gitlab-clone-all --host=GITLAB_DOMAIN --group=GROUP_PATH

Clone all repositories from a GitLab group.

Requires: glab CLI authenticated with the target GitLab instance.
  Run: glab auth login --hostname GITLAB_DOMAIN

Options:
  --host=GITLAB_DOMAIN     GitLab instance domain (e.g., gitlab.com)
  --group=GROUP_PATH       Group path to clone repositories from (e.g., my-org/sub-group)
  -h, --help               Show this help message

Examples:
  git gitlab-clone-all --host=gitlab.com --group=my-org
  git gitlab-clone-all --host=gitlab.example.com --group=my-org/sub-group
EOF
    exit 0
}

#
# Argument parsing
#

parse_args() {
    HOST=""
    GROUP=""

    for arg in "$@"; do
        case $arg in
            --host=*)
                HOST="${arg#*=}"
                ;;
            --group=*)
                GROUP="${arg#*=}"
                ;;
            -h|--help)
                usage
                ;;
            *)
                die "Unknown option: $arg"
                ;;
        esac
    done

    # Validate required parameters
    [[ -z "$HOST" ]] && die "--host is required"
    [[ -z "$GROUP" ]] && die "--group is required"

    # Trim whitespace and newlines from GROUP
    GROUP=$(echo -n "$GROUP" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
}

#
# GitLab API via glab
#

url_encode() {
    printf '%s' "$1" | jq -sRr @uri
}

verify_glab_auth() {
    if ! glab auth status --hostname "$HOST" >/dev/null 2>&1; then
        die "Not authenticated with $HOST. Run: glab auth login --hostname $HOST"
    fi
}

#
# Project discovery
#

get_all_projects() {
    local encoded_group
    encoded_group=$(url_encode "$GROUP")

    local endpoint="groups/${encoded_group}/projects?per_page=100&include_subgroups=true&archived=false&with_shared=false"

    echo "Fetching projects from GitLab API..." >&2
    local projects
    # glab --paginate outputs each page as separate JSON array, combine with jq -s 'add'
    if ! projects=$(glab api --hostname "$HOST" --paginate "$endpoint" 2>&1 | jq -s 'add // []'); then
        die "API error: $projects"
    fi

    # Check if response is an array (not an error object)
    if ! echo "$projects" | jq -e 'type == "array"' >/dev/null 2>&1; then
        die "API error: $(echo "$projects" | jq -r '.message // .error // "Unknown error"')"
    fi

    echo "$projects"
}

verify_group_exists() {
    local encoded_group
    encoded_group=$(url_encode "$GROUP")

    local group_info
    if ! group_info=$(glab api --hostname "$HOST" "groups/${encoded_group}?with_projects=false" 2>&1); then
        die "Group '$GROUP' not found or not accessible: $group_info"
    fi

    # Check if the group exists by looking for an error or empty response
    if [[ -z "$group_info" ]] || echo "$group_info" | jq -e '.message' >/dev/null 2>&1; then
        if echo "$group_info" | jq -e '.message' >/dev/null 2>&1; then
            die "Group '$GROUP' not found. GitLab API error: $(echo "$group_info" | jq -r '.message')"
        fi
        die "Group '$GROUP' not found or not accessible."
    fi

    local group_name
    group_name=$(echo "$group_info" | jq -r '.full_name // .full_path // .name // "unknown"')
    echo "Group found: $group_name"
}

#
# Clone operations
#

clone_repo() {
    local ssh_url="$1"
    local path_with_namespace="$2"

    # Create directory structure if it doesn't exist
    local dir_path
    dir_path=$(dirname "$path_with_namespace")
    if [[ "$dir_path" != "." ]]; then
        mkdir -p "$dir_path"
    fi

    if [[ -d "$path_with_namespace" ]]; then
        print_yellow "  Directory already exists, skipping: $path_with_namespace"
        return 0
    fi

    echo "  Cloning: $ssh_url -> $path_with_namespace"
    if git clone "$ssh_url" "$path_with_namespace"; then
        print_green "  Successfully cloned: $path_with_namespace"
    else
        print_red "  Failed to clone: $path_with_namespace"
        return 1
    fi
}

#
# Main
#

main() {
    parse_args "$@"

    echo "GitLab Clone All Repositories"
    echo "Host: $HOST"
    echo "Group: $GROUP"
    echo ""

    echo "Verifying glab authentication..."
    verify_glab_auth
    echo ""

    echo "Verifying group exists..."
    verify_group_exists
    echo ""

    echo "Fetching repositories from GitLab..."
    local projects
    projects=$(get_all_projects)

    if [[ -z "$projects" ]] || [[ "$projects" == "null" ]] || [[ $(echo "$projects" | jq '. | length') -eq 0 ]]; then
        echo "No repositories found."
        exit 0
    fi

    local project_count
    project_count=$(echo "$projects" | jq '. | length')
    echo "Found $project_count repositories to clone"
    echo ""

    # Process each project
    echo "$projects" | jq -r '.[] | "\(.ssh_url_to_repo)|\(.path_with_namespace)"' | while IFS='|' read -r ssh_url path_with_namespace; do
        clone_repo "$ssh_url" "$path_with_namespace"
    done

    echo ""
    print_green "GitLab clone operation completed!"
}

main "$@"
