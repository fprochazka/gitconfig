#!/usr/bin/env bash

set -euo pipefail

#
# Configuration
#

MAX_JOBS=10
TIMEOUT_SECONDS=60
PROGRESS_FILE=""

#
# Output helpers
#

color_red() { echo -e "\033[31m$1\033[0m"; }
color_green() { echo -e "\033[32m$1\033[0m"; }
color_yellow() { echo -e "\033[33m$1\033[0m"; }
color_bold() { echo -e "\033[1m$1\033[0m"; }

#
# Usage
#

usage() {
    cat <<EOF
Usage: git sync-all-repos [DIRECTORY]

Recursively find all git repositories and sync them with their remotes.
For each repository, this command will:
  1. Run 'git fetch --all' to update remote refs
  2. Run 'git pull' if the working tree is clean and on main/master branch

The script processes repositories in parallel for better performance.

Arguments:
  DIRECTORY    Directory to scan for git repositories (default: current directory)

Behavior:
  - Skips repositories with uncommitted changes
  - Only pulls on main/master branches with tracking remotes
  - Processes up to $MAX_JOBS repositories concurrently
  - Shows colored output to distinguish success/failure
  - Times out after $TIMEOUT_SECONDS seconds per git operation

Examples:
  git sync-all-repos
  git sync-all-repos ~/projects
  git sync-all-repos /path/to/workspace

Options:
  -h, --help    Show this help message
EOF
    exit 1
}

#
# Cleanup
#

cleanup() {
    echo -e "\n\033[33mInterrupted, stopping...\033[0m"
    pkill -P $$ 2>/dev/null || true
    [[ -n "$PROGRESS_FILE" ]] && rm -f "$PROGRESS_FILE" 2>/dev/null || true
    exit 130
}

#
# Repository discovery
#

find_repos() {
    local dir="$1"
    find "$dir" -name ".git" -type d 2>/dev/null | while read -r git_dir; do
        echo "${git_dir%/.git}"
    done
}

#
# Progress tracking
#

increment_progress() {
    local progress_file="$1"
    flock "$progress_file" bash -c "
        n=\$(cat '$progress_file' 2>/dev/null || echo 0)
        echo \$((n + 1)) > '$progress_file'
        cat '$progress_file'
    "
}

#
# Git operations
#

git_fetch() {
    local repo_path="$1"
    local timeout_seconds="$2"
    timeout "${timeout_seconds}s" git -C "$repo_path" \
        -c credential.helper= \
        -c core.askPass= \
        fetch --all 2>&1
}

git_pull() {
    local repo_path="$1"
    local timeout_seconds="$2"
    timeout "${timeout_seconds}s" git -C "$repo_path" \
        -c credential.helper= \
        -c core.askPass= \
        pull 2>&1
}

is_working_tree_clean() {
    local repo_path="$1"
    git -C "$repo_path" diff --quiet 2>/dev/null && \
    git -C "$repo_path" diff --cached --quiet 2>/dev/null
}

get_current_branch() {
    local repo_path="$1"
    git -C "$repo_path" rev-parse --abbrev-ref HEAD 2>/dev/null
}

has_upstream() {
    local repo_path="$1"
    git -C "$repo_path" rev-parse --abbrev-ref @{u} >/dev/null 2>&1
}

is_main_branch() {
    local branch="$1"
    [[ "$branch" =~ ^(master|main)$ ]]
}

#
# Repository processing
#

process_repo() {
    local repo_path="$1"
    local total="$2"
    local progress_file="$3"
    local timeout_seconds="$4"

    local status="ok"
    local pulled="no"

    # Fetch (discard output, we only care about success/failure)
    if ! git_fetch "$repo_path" "$timeout_seconds" >/dev/null 2>&1; then
        status="fetch-failed"
    fi

    # Pull if appropriate
    local current_branch=""
    if [[ "$status" == "ok" ]]; then
        if ! current_branch=$(get_current_branch "$repo_path"); then
            status="empty-repo"
        elif is_working_tree_clean "$repo_path" && is_main_branch "$current_branch"; then
            if has_upstream "$repo_path"; then
                if git_pull "$repo_path" "$timeout_seconds" >/dev/null 2>&1; then
                    pulled="yes"
                else
                    status="pull-failed"
                fi
            else
                status="no-upstream"
            fi
        else
            status="dirty-or-branch"
        fi
    fi

    # Update progress counter
    local current
    current=$(increment_progress "$progress_file")

    # Output result
    print_result "$current" "$total" "$status" "$pulled" "$repo_path" "$current_branch"
}

print_result() {
    local current="$1"
    local total="$2"
    local status="$3"
    local pulled="$4"
    local repo_path="$5"
    local current_branch="${6:-}"

    local color suffix
    case "$status" in
        ok)
            color="\033[32m"
            if [[ "$pulled" == "yes" ]]; then
                suffix="fetched + pulled"
            else
                suffix="fetched"
            fi
            ;;
        fetch-failed)  color="\033[31m"; suffix="fetch failed/timeout" ;;
        pull-failed)   color="\033[31m"; suffix="pull failed/timeout" ;;
        empty-repo)    color="\033[33m"; suffix="empty repository" ;;
        no-upstream)   color="\033[33m"; suffix="no tracking branch" ;;
        dirty-or-branch) color="\033[33m"; suffix="skipped: dirty or not main, $current_branch is checked out" ;;
        *)             color="\033[0m";  suffix="unknown" ;;
    esac

    echo -e "${color}[$current/$total] ($suffix)\033[0m $repo_path"
}

#
# Main
#

main() {
    # Handle help flag
    if [[ "${1:-}" == "-h" ]] || [[ "${1:-}" == "--help" ]]; then
        usage
    fi

    trap cleanup SIGINT SIGTERM

    local start_dir="${1:-.}"

    echo "Scanning for git repositories..."

    local repo_list
    if ! repo_list=$(find_repos "$start_dir"); then
        echo "Failed to scan for repositories"
        exit 1
    fi

    if [[ -z "$repo_list" ]]; then
        echo "No git repositories found in $start_dir"
        exit 0
    fi

    local repo_count
    repo_count=$(echo "$repo_list" | wc -l)
    echo "Found $repo_count git repositories. Processing with concurrency=$MAX_JOBS..."
    echo ""

    # Create progress file for atomic counter
    PROGRESS_FILE=$(mktemp)
    echo "0" > "$PROGRESS_FILE"

    # Export functions for xargs subshells
    export -f process_repo print_result increment_progress
    export -f git_fetch git_pull is_working_tree_clean get_current_branch has_upstream is_main_branch

    # Process repositories in parallel
    printf '%s\n' "$repo_list" | xargs -I {} -P "$MAX_JOBS" \
        bash -c 'process_repo "$1" "$2" "$3" "$4"' _ {} "$repo_count" "$PROGRESS_FILE" "$TIMEOUT_SECONDS"

    # Cleanup
    rm -f "$PROGRESS_FILE"

    echo ""
    echo "Done syncing $repo_count repositories."
}

main "$@"
