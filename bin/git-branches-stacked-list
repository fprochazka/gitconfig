#!/usr/bin/env bash

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/lib/common.sh"

#
# Usage
#

usage() {
    cat <<EOF
Usage: git branches-stacked-list [--with-remotes] [--all]

Lists all local branches that contain commits from the current branch.
By default, only shows branches with tracking remotes.

Options:
  --with-remotes    Include remote tracking information in output
  --all             Show all branches, even without tracking remotes
  -h, --help        Show this help message
EOF
    exit 0
}

#
# Argument parsing
#

parse_args() {
    SHOW_REMOTES=false
    SHOW_ALL=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --with-remotes)
                SHOW_REMOTES=true
                shift
                ;;
            --all)
                SHOW_ALL=true
                shift
                ;;
            -h|--help)
                usage
                ;;
            *)
                die "Unknown option: $1"
                ;;
        esac
    done
}

#
# Branch discovery
#

get_commits_in_branch() {
    local main_branch="$1"
    local current_branch="$2"
    git rev-list "${main_branch}..${current_branch}" 2>/dev/null || true
}

get_branches_containing_commit() {
    local commit="$1"
    git branch --contains "$commit" 2>/dev/null \
        | grep -v '^\s*remotes/' \
        | sed 's/^\s*\*//' \
        | sed 's/^\s*//' \
        || true
}

has_tracking_remote() {
    local branch="$1"
    git config "branch.${branch}.remote" >/dev/null 2>&1
}

find_stacked_branches() {
    local main_branch="$1"
    local current_branch="$2"
    local show_all="$3"

    local commits_in_branch
    commits_in_branch=$(get_commits_in_branch "$main_branch" "$current_branch")

    if [[ -z "$commits_in_branch" ]]; then
        return
    fi

    local -A branches_found=()

    for commit in $commits_in_branch; do
        local commit_branches
        commit_branches=$(get_branches_containing_commit "$commit")

        for branch in $commit_branches; do
            # Skip if branch is already in our set
            if [[ -n "${branches_found[$branch]:-}" ]]; then
                continue
            fi

            # Include all branches or only those with tracking remotes
            if [[ "$show_all" == "true" ]] || has_tracking_remote "$branch"; then
                branches_found[$branch]=1
            fi
        done
    done

    # Output sorted branch names
    printf '%s\n' "${!branches_found[@]}" | sort
}

#
# Output
#

print_branch_info() {
    local branch="$1"
    local show_remotes="$2"

    if [[ "$show_remotes" == "true" ]]; then
        if has_tracking_remote "$branch"; then
            local remote
            local remote_branch
            remote=$(get_branch_remote "$branch")
            remote_branch=$(get_branch_upstream "$branch")
            echo "$branch -> $remote/$remote_branch"
        else
            echo "$branch (no tracking remote)"
        fi
    else
        echo "$branch"
    fi
}

#
# Main
#

main() {
    parse_args "$@"

    require_git_repo

    local current_branch
    current_branch=$(get_current_branch)

    local main_branch
    main_branch=$(get_main_branch)

    local branches
    branches=$(find_stacked_branches "$main_branch" "$current_branch" "$SHOW_ALL")

    if [[ -z "$branches" ]]; then
        exit 0
    fi

    while IFS= read -r branch; do
        print_branch_info "$branch" "$SHOW_REMOTES"
    done <<< "$branches"
}

main "$@"
